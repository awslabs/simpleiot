# Â© 2022 Amazon Web Services, Inc. or its affiliates. All Rights Reserved.
#
# SimpleIOT project.
# Author: Ramin Firoozye (framin@amazon.com)
#
# SimpleIOT: App Layer: IOT Thing
# iotthing.py
#
# Common IOT Core operations that lambdas may need to perform.
#
import json
import boto3
from botocore.exceptions import ClientError
import requests
from iotapp.params import create_secret, delete_param
from iotapp.logger import *
import os


AMAZON_ROOT_CA_CERT_URL = "https://www.amazontrust.com/repository/AmazonRootCA1.pem"

iot = boto3.client('iot')

#
# Use this to create an IOT thing along with certs, keys, and policies. If return_certs
# is set to True, we return the certificates in the return result. Note that this makes the
# returned payload pretty large (and can be a potential security issue).
#
# The other option is to specify that the certs be placed in SSM secure store with a
# synthesized key and then return the key in the return result.
# The caller is then responsible for going to get those and deleting them. Note that there's a
# max number of elements that can be stored SSM parameter store (10K as of this writing) so
# if the certs aren't stored elsewhere, there's a potential time-bomb if every device creates
# a cert/public/private key and DOESN'T delete it out of parameter store.
#
# For the CA there are two choices: either pass None and the default AWS CA located at
# https://www.amazontrust.com/repository/AmazonRootCA1.pem
# will be used, or specify the URL of a service that returns the PEM version of the certificate.
# That will be returned in-line if return_certs_inline is specified.

#
# NOTE that if debug flag is set AND the certs are returned inline, the
# debug logs will contain the actual pem and keys which could end up in the
# logs. Only use this for development/debugging.
#
# Best practice is to store the keys in the SSM store, return the key names
# then have a separate mecahnism retreive the actual values, store them
# in a separate secure store (like an encrypted vault or db field) and then
# delete the SSM parameters. There is a size limit on the number of SSM keys
# so we can't use this mechanism for production.
#

def create_iot_thing(namespace,
                     name,
                     uuid=None,
                     param_prefix="",
                     return_certs_inline=False,
                     certs_in_ssm=False,
                     root_ca_cert_url=AMAZON_ROOT_CA_CERT_URL):
    data = {}
    ca_data = None

    #ldebug(f"create_iot_thing: ns: {namespace}, name: {name} inline: {return_certs_inline}, ssm: {certs_in_ssm}")
    if uuid:
        ldebug(f"create_iot_thing: +uuid: {uuid}")

    # Stuff we return in the result payload
    #
    data['namespace'] = namespace
    if uuid:
        data['uuid'] = uuid
    data['name'] = name

    cert_data = iot.create_keys_and_certificate(setAsActive=True)
    data['cert_id'] = cert_data["certificateId"]
    data['cert_arn'] = cert_data["certificateArn"]

    # Let's go get the CA certificate in PEM format. If not specified,
    # we use the standard AmazonRootCA1 version.
    #
    ca_request = requests.request("GET", root_ca_cert_url)
    if ca_request.status_code == 200:
        ca_data = ca_request.text

    if return_certs_inline:
        #ldebug("create_iot_thing - returning cert values inline")

        data['cert_pem'] = cert_data['certificatePem']
        data['public_key'] = cert_data['keyPair']['PublicKey']
        data['private_key'] = cert_data['keyPair']['PrivateKey']
        if ca_data:
            data['ca_pem'] = ca_data

    if certs_in_ssm:
        #ldebug("create_iot_thing - returning cert values in SSM")

        if ca_data:
            ca_pem_name = f"{param_prefix}/ca_pem_{name}_{uuid}"
            create_secret(ca_pem_name, ca_data, f"Root CA PEM for {name}_{uuid}")
            data['ca_pem_name'] = ca_pem_name

        cert_pem_name = f"{param_prefix}/cert_pem_{name}_{uuid}"
        public_key_name = f"{param_prefix}/public_key_{name}_{uuid}"
        private_key_name = f"{param_prefix}/private_key_{name}_{uuid}"
        create_secret(cert_pem_name, cert_data['certificatePem'], f"Certificate PEM for {name}_{uuid}")
        create_secret(cert_pem_name, cert_data['certificatePem'], f"Certificate PEM for {name}_{uuid}")
        create_secret(public_key_name, cert_data['keyPair']['PublicKey'], f"Public Key for {name}_{uuid}")
        create_secret(private_key_name, cert_data['keyPair']['PrivateKey'], f"Private Key for {name}_{uuid}")
        #ldebug(f"SSM keys - cert: {cert_pem_name} - public_key: {public_key_name} - private_key: {private_key_name}")
        data['cert_pem_name'] = cert_pem_name
        data['public_key_name'] = public_key_name
        data['private_key_name'] = private_key_name

    # Now we go create a Thing with this device name and type
    #
    try:
        if uuid:
            thing_name = f"{namespace}_{name}_thing_{uuid}"
        else:
            thing_name = f"{namespace}_{name}_thing"

        response = iot.create_thing(thingName=thing_name)
        #ldebug(f"Thing {thing_name} created")
        data["thing_name"] = thing_name

        thing_arn = response['thingArn']
        data["thing_arn"] = thing_arn

        #
        # Now we create a policy and attach it to the thing.
        #
        policy_data = {
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Effect": "Allow",
                    "Action": [
                        "greengrass:*",
                        "iot:Connect",
                        "iot:Publish",
                        "iot:Subscribe",
                        "iot:Receive",
                        "iot:GetThingShadow",
                        "iot:AttachPrincipalPolicy",
                        "cognito-sync:*",
                        "mobileanalytics:PutEvents"
                    ],
                    "Resource": [
                        # "arn:aws:iot:{0}:*:*".format(region)
                        "*"
                    ]
                },
                {
                    "Effect": "Allow",
                    "Action": "sqs:SendMessage",
                    "Resource": "*"
                }
            ]
        }

        policy_str = json.dumps(policy_data)
        response = {}

        try:
            if uuid:
                policy_name = f"{namespace}_{name}_policy_{uuid}"
            else:
                policy_name = f"{namespace}_{name}_policy"

            response = iot.create_policy(
                policyName=policy_name,
                policyDocument=policy_str
            )
        except Exception as e:
            lerror(f"ERROR: could not create a policy to attach to {namespace}: {str(e)}")
            return None

        policy_arn = response['policyArn']
        policy_name = response['policyName']

        #ldebug(f"Policy {policy_name} created")

        data['policy_arn'] = policy_arn
        data['policy_name'] = policy_name

        cert_arn = data["cert_arn"]
        try:

            # Now we attach the policy and certs to the thing
            #
            # response = iot.attach_principal_policy(policyName=policy_name,
            #                             principal=cert_arn)
            #
            response = iot.attach_policy(
                policyName=policy_name,
                target=cert_arn
            )
        except ClientError as ce:
            # if policy already exists return nothing, assuming previous success
            if ce.response['Error']['Code'] == 'ResourceAlreadyExistsException':
                lwarning("Thing policy {policy_name} already exists: {0}".format(
                    ce.response['Error']['Message']))
            else:
                lerror("Error creating thing policy name {policy_name}: {0}".format(
                    ce.response['Error']['Message']))
                raise ce

        except Exception as e:
            lerror(f"ERROR: could not attach policy to device: {namespace}: {str(e)}")
            return None

        #ldebug(f"Policy {policy_name} attached to {namespace}")

        thing_name = data["thing_name"]

        try:
            response = iot.attach_thing_principal(
                thingName=thing_name,
                principal=cert_arn
            )
        except Exception as e:
            ldebug(f"ERROR: could not attach thing principal for: {namespace}: {str(e)}")
            return None

        #ldebug(f"Thing {thing_name} attached to Principal {cert_arn}")

        resp = iot.describe_endpoint(endpointType="iot:Data-ATS")
        iot_endpoint = resp["endpointAddress"]
        data['iot_endpoint'] = iot_endpoint
        #ldebug(f"Endpoint: {iot_endpoint}")

        ldebug(f"SUCCESS: Device Thing for '{namespace}' created'")
        # result = json.dumps(data, indent=4)
        # ldebug(f"IOT create response: {result}")
        return data

    except Exception as e:
        lerror(f"ERROR: could not create Things for {namespace}: {str(e)}")
        return None

#
# Deletes all the IOT data related to a single device. NOTE: if an iot_rule param is returned,
# we'll delete that as well (assuming it's a comma-separated list of rule names).
# Or you can just call the delete_rule function.
#
def delete_iot_thing(data):
    #ldebug(f"Deleting IOT Thing with data: {data}")
    cert_arn = data.get("cert_arn", None)
    cert_id = data.get("cert_id", None)
    thing_name = data.get("thing_name", None)
    iot_policy_name = data.get("policy_name", None)
    iot_rule = data.get("iot_rule", None)
    ca_pem_name = data.get('ca_pem_name', None)
    cert_pem_name = data.get('cert_pem_name', None)
    public_key_name = data.get('public_key_name', None)
    private_key_name = data.get('private_key_name', None)

    if iot_policy_name and cert_arn:
        try:
            # ldebug(f"Detaching principal policy {policy_name} from cert: {cert_arn}")
            # iot.detach_principal_policy(policyName=policy_name, principal=cert_arn)
            #
            #ldebug(f"Detaching policy: {iot_policy_name} from cert: {cert_arn}")
            result = iot.detach_policy(policyName=iot_policy_name, target=cert_arn)
        except Exception as e:
            pass

    if iot_policy_name:
        try:
            #ldebug(f"Deleting policy: {iot_policy_name}")
            result = iot.delete_policy(policyName=iot_policy_name)
        except Exception as e:
            pass

    if iot_rule:
        try:
            rule_list = iot_rule.split(",")
            for rule_name in rule_list:
                #ldebug(f"Deleting IOT rule: {rule_name}")
                result = iot.delete_topic_rule(ruleName=rule_name)
        except Exception as e:
            pass

    if thing_name and cert_arn:
        try:
            #ldebug(f"Detaching thing principal: {thing_name} from cert: {cert_arn}")
            result = iot.detach_thing_principal(thingName=thing_name, principal=cert_arn)
        except Exception as e:
            pass

    if thing_name:
        try:
            #ldebug(f"Deleting thing named: {thing_name}")
            result = iot.delete_thing(thingName=thing_name, expectedVersion=1)
        except Exception as e:
            pass

    if cert_id:
        try:
            #ldebug(f"Marking certificate as inactive: {cert_id}")
            iot.update_certificate(certificateId=cert_id, newStatus='INACTIVE')
            #ldebug(f"Deleting certificate: {cert_id}")
            result = iot.delete_certificate(certificateId=cert_id, forceDelete=True)
        except Exception as e:
            pass


    # Some cert book-keeping. If the certificate, public key and private keys have NOT
    # been deleted from the SSM parameter store, we look to see if the key names were
    # defined during create phase, we try to delete them.
    #
    # But hopefully, it won't be necessary and these have been downloaded and stored separately
    # and deleted from the parameter store. There is a size limit on the parameter store
    # so for each Thing created there will be three slots taken up. As of this writing
    # there's a 10K count limit so after 3333 things, you will inexplicably not be able
    # to add more things and bad things will happen.
    #
    # Best practice is to download the cert/public/private keys in secure SSM parameter
    # store, with the names of the keys returned in the result payload in create (above),
    # store them somewhere secure (for example, an encrypted field in a database) and
    # delete them from the parameter store.
    #
    if ca_pem_name:
        #ldebug(f"Deleting Root CA PEM: {ca_pem_name} from SSM")
        delete_param(ca_pem_name)
    if cert_pem_name:
        #ldebug(f"Deleting Cert PEM: {cert_pem_name} from SSM")
        delete_param(cert_pem_name)
    if public_key_name:
        #ldebug(f"Deleting Public Key: {public_key_name} from SSM")
        delete_param(public_key_name)
    if private_key_name:
        #ldebug(f"Deleting Private Key: {private_key_name} from SSM")
        delete_param(private_key_name)

    #ldebug(f"IOT Core parts deleted.")

    result = {'statusCode': 200,
              'status': 'ok'
              }
    return result

#
# We assume the payload is a JSON array of rules, constructed as:
#
# [
# {
#     "name": "{rulename}",
#     "rule": "{json string rule}"
# },
# ...
#
# Once created, the list of rule names and their ARNs will be returned as a json structure.
# To delete the rules, just return the same json to delete_rules and we loop
# through and get rid of them.
#

def create_iot_rules(rule_json):
    iot_rule_names = {}
    rules_list = json.loads(rule_json)

    try:
        for rule_def in rules_list:
            rule_name = rule_def["name"]
            #ldebug(f"Creating IOT rule {rule_name}")
            iot_rule_names.append(rule_name)
            rule_body = rule_def["rule"]
            iot.create_topic_rule(ruleName=rule_name,
                                           topicRulePayload=rule_body)
            response = iot.get_topic_rule(ruleName=rule_name)
            rule_arn = response["ruleArn"]
            #ldebug(f"Created rule {rule_name} - arn: {rule_arn}")
            iot_rule_names[rule_name] = rule_arn

    except Exception as e:
        pass

    return json.dumps(iot_rule_names, indent=2)


def delete_iot_rules(rule_names):
    if rule_names:
        #ldebug(f"Deleting IOT Rules with data: {rule_names}")
        try:
            rules = json.loads(rule_names)
            for rule_name, rule_arn in rules.items():
                #ldebug(f"Deleting IOT rule: {rule_name}")
                result = iot.delete_topic_rule(ruleName=rule_name)
                #ldebug(f"Deleted rule {rule_name} - result: {result}")
        except Exception as e:
            pass