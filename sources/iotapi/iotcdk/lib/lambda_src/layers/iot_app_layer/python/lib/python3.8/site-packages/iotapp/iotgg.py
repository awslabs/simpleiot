# Â© 2022 Amazon Web Services, Inc. or its affiliates. All Rights Reserved.
#
# SimpleIOT project.
# Author: Ramin Firoozye (framin@amazon.com)
#
# SimpleIOT: App Layer: Greengrass
# iotgg.py
#
# This creates a GG Core (including the embedded IOT Thing) and returns settings
# data in the same format as the iotthing.py library.

import json
import os
import boto3
from boto3.session import Session
from botocore.exceptions import ClientError
import uuid
from iotapp.params import create_secret, delete_param
from iotapp.iotthing import *
from iotapp.logger import *

iot = boto3.client('iot')
iam = boto3.client('iam')
_lambda = boto3.client('lambda')
gg = boto3.client('greengrass')
gg2 = boto3.client('greengrassv2')


ROOT_CA_URL = "https://www.amazontrust.com/repository/AmazonRootCA1.pem"
DEPLOY_TIMEOUT_SECS = 90
DEFAULT_GG_SYNC_SHADOW = False


#
# This will create a new GG group, using a local lambda. We're
# assuming the config data is defined in the params.
#
# NOTE: we assume the lambda to be deployed to GG is already created and its arn
# can be discovered at runtime. Ordinarily, it would be defined as
# part of the CDK.
#
# The data part is used as incoming data to the GG creation process and then passed on
# to next stages.
#
def create_iot_gg(data, prefix,
                    name,
                    uuid=None,
                    param_prefix="",
                    return_certs_inline=False,
                    certs_in_ssm=False,
                    root_ca_cert_url=AMAZON_ROOT_CA_CERT_URL,
                    v2=True):

    data['prefix'] = prefix
    data['id'] = uuid

    #ldebug(f"PROVISIONING IOT GG")
    iot_thing_data = create_iot_thing(prefix, name, uuid, param_prefix, return_certs_inline,
                                   certs_in_ssm, root_ca_cert_url)
    if iot_thing_data:
        # We merge IOT Thing data back into the passed-down data for subsequent stages.
        #
        data = {**data, **iot_thing_data}
        #ldebug(f"Got results from IOT creation: {json.dumps(data, indent=4)}")

        # Next we create the IAM roles needed by GG.
        #
        data = create_iam_role(prefix, data)

        # Now Greengrass definitions.
        #
        if not v2:
            #("Creating GGv1 Core")
            data["v2"] = False

            data = create_gg_group(prefix, data)
            data = create_gg_core(prefix, data)

            # NOTE: devices can be assigned to gg separately, since they may be provisioned and
            # created after the GG has already been created. Same with resources and connectors.
            # Lambdas and subscriptions, however, aren't likely to change so we can create them
            # here.
            #
            # if "gg_device_def" in data:
            #   data = create_gg_devices(prefix, data)
            # if "gg_resource_def" in data:
            #   data = create_gg_resources(prefix, data)
            data = create_gg_lambdas(prefix, data)
            # if "gg_connector_def" in data:
            #   data = create_gg_connectors(prefix, data)
            if "gg_subscription_def" in data:
                data = create_gg_subscriptions(prefix, data)
            # if "gg_log_def" in data:
            #   data = create_gg_loggers(prefix, data)
            data = create_gg_version(prefix, data)
            data = deploy_gg(prefix, data)
        else:
            # In v2, we create the things and then return the data back so the rest of the
            # GG Nucleus provisioning can be done on the device, either manually or via an ssh
            # script.
            #
            ldebug("Creating GGv2 Core -- needs to be continued on device")
            data["v2"] = True
            data["uuid"] = uuid

        #ldebug(f"GG PROVISION DONE: {json.dumps(data, indent=2)}")
        return data
    else:
        ldebug("ERROR: problem creating IOT Thing for Greengrass Core")
        return None

#
# This will remove everything for this group. The data passed is assumed to be
# a JSON, which should be what we passed back during the create stage.
#
def delete_iot_gg(data):
    try:
        #ldebug(f"DELETING IOT GG")
        v2 = data.get("v2", False)
        if v2:
            #
            # We may need to loop through all the components as well and remove them.
            #
            data = remove_iam_role(data)
            thing_name = data.get("thing_name", None)
            if thing_name:
                delete_iot_thing(data)
                gg2.delete_core_device(coreDeviceThingName=thing_name)
            #
            # Also delete all the deployments, devices, and components.
            #
        else:
            prefix = data.get('prefix', None)
            if prefix:
                data = remove_gg_subscriptions(data)
                # data = remove_gg_devices(data)
                data = remove_gg_lambdas(data)
                # data = remove_gg_resources(data)
                # data = remove_gg_connectors(data)
                # data = reset_gg_loggers(data)
                data = reset_gg_deployments(data)
                data = remove_gg_core(data)
                data = remove_gg_group(data)
                data = remove_iam_role(data)
                #
                # Thing creation data should already be in the payload (if created using create_iot_gg.
                # So we pass it down and let the delete_iot_thing function extract what it needs to cleanly
                # remove the IOT Thing.
                #
                delete_iot_thing(data)
                #ldebug(f"GG Delete DONE")
            else:
                ldebug("ERROR: invalid parameters sent to delete_iot_gg")
                return None

        return data
    except Exception as e:
        ldebug(f"ERROR: can not delete GG2 device: {str(e)}")
        return None


#################################################################
# Roles
#
# This creates a role in IAM, then attaches it to the GG account.
#

aws_lambda_ro_access_arn = "arn:aws:iam::aws:policy/AWSLambda_ReadOnlyAccess"
aws_iot_full_access_arn = "arn:aws:iam::aws:policy/AWSIoTFullAccess"
aws_gg_full_access_arn = "arn:aws:iam::aws:policy/AWSGreengrassFullAccess"
aws_gg_assume_role_arn = "arn:aws:iam::aws:policy/service-role/AWSGreengrassResourceAccessRolePolicy"

def create_iam_role(prefix, data):
    #ldebug(f"GG: create_iam_role")
    device_id = data.get("id", "")
    role_name = f"{prefix}_gg_service_role_{device_id}"
    data['gg_role_name'] = role_name

    assume_role_policy = {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Effect": "Allow",
                "Principal": {
                    "Service": "greengrass.amazonaws.com"
                },
                "Action": "sts:AssumeRole"
            }
        ]
    }

    try:
        #ldebug(f"Creating role: {role_name}")
        status = iam.create_role(
            RoleName=role_name,
            AssumeRolePolicyDocument=json.dumps(assume_role_policy)
        )

        #ldebug(f"Attaching lambda role policy for {role_name}")
        status = iam.attach_role_policy(
            RoleName=role_name,
            PolicyArn=aws_lambda_ro_access_arn
        )

        #ldebug(f"Attaching IOT role policy for {role_name}")
        status = iam.attach_role_policy(
            RoleName=role_name,
            PolicyArn=aws_iot_full_access_arn
        )

        #ldebug(f"Attaching greengrass role policy for {role_name}")
        status = iam.attach_role_policy(
            RoleName=role_name,
            PolicyArn=aws_gg_full_access_arn
        )

        #ldebug(f"Attaching greengrass assume role policy for {role_name}")
        status = iam.attach_role_policy(
            RoleName=role_name,
            PolicyArn=aws_gg_assume_role_arn
        )

        # Now we create the actual Role object -- with the above policies
        #
        region = os.environ['AWS_REGION']
        #ldebug(f"Creating Role name: {role_name} for region: {region}")
        iam_session = Session(region_name=region).resource('iam')
        service_role = iam_session.Role(role_name)

        #   ldebug(f"Associating service role to account")
        #   gg.associate_service_role_to_account(RoleArn=service_role.arn)
        #   ldebug(f"[create_iam_role] service role attached to account: {service_role.arn}")

        data['region'] = region
        data["service_role_arn"] = service_role.arn

    # role already exists return nothing, assuming previous success
    except ClientError as ce:
        if ce.response['Error']['Code'] == 'ResourceAlreadyExistsException':
            lwarning("Role already exists {0}".format(ce.response['Error']['Message']))
        else:
            lerror(f"Role creation error for role {role_name} {0}".format(
                ce.response['Error']['Message']))
            raise ce

    return data


def remove_iam_role(data):
    #ldebug(f"Removing IAM role")
    role_name = data.get("gg_role_name", None)
    service_role_arn = data.get("service_role_arn", None)

    try:
        if role_name:
            # NOTE NOTE NOTE: If we associate and dissociate custom roles from the account
            # It's possible we'll mess up deployments by cores that don't have that role.
            # For now, we're commentint this out, but in the IOT Core>Greengrass>Settings, from the console
            # needs to be assigned to a role that allows: AWSGreengrassResourceAccessRolePolicy

            #    ldebug(f"Dissociate GG service role from account")
            #    gg.disassociate_service_role_from_account()
            #ldebug(f"Detach lambda role policy: {role_name}")
            iam.detach_role_policy(RoleName=role_name, PolicyArn=aws_lambda_ro_access_arn)
            #ldebug(f"Detach iot role policy: {role_name}")
            iam.detach_role_policy(RoleName=role_name, PolicyArn=aws_iot_full_access_arn)
            #ldebug(f"Detach gg role policy: {role_name}")
            iam.detach_role_policy(RoleName=role_name, PolicyArn=aws_gg_full_access_arn)
            #ldebug(f"Detach gg assume role policy: {role_name}")
            iam.detach_role_policy(RoleName=role_name, PolicyArn=aws_gg_assume_role_arn)
            #ldebug(f"Deleting role: {role_name}")
            iam.delete_role(RoleName=role_name)
            #ldebug(f"Roles deleted")
    except Exception as e:
        lerror(f"Error removing iam_role {role_name}: {str(e)}")
        raise e

    return data


def create_iam_role_with_inline(prefix, data):
    #ldebug(f"GG: create_iam_role")
    device_id = data.get("id", "")
    role_name = f"{prefix}_gg_service_role_{device_id}"
    data['gg_role_name'] = role_name


    assume_role_policy = {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Effect": "Allow",
                "Principal": {
                    "Service": "greengrass.amazonaws.com"
                },
                "Action": "sts:AssumeRole"
            }
        ]
    }
    gg_inline_policy = {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Sid": "g3s20170630",
                "Effect": "Allow",
                "Action": [
                    "greengrass:*"
                ],
                "Resource": [
                    "*"
                ]
            }
        ]
    }

    try:
        #ldebug(f"Creating GG role: {role_name}")
        status = iam.create_role(
            RoleName=role_name,
            AssumeRolePolicyDocument=json.dumps(assume_role_policy)
        )

        #ldebug(f"Attaching lambda role policy")
        status = iam.attach_role_policy(
            RoleName=role_name,
            PolicyArn=aws_lambda_ro_access_arn
        )

        #ldebug(f"Attaching lambda role policy")
        status = iam.attach_role_policy(
            RoleName=role_name,
            PolicyArn=aws_iot_full_access_arn
        )

        inline_role_name = prefix + '_gg_inline_policy'

        #ldebug(f"Putting inline role policy {inline_role_name}")
        status = iam.put_role_policy(
            RoleName=role_name,
            PolicyName=inline_role_name,
            PolicyDocument=json.dumps(gg_inline_policy)
        )
        data['gg_inline_role_name'] = inline_role_name

        # Now we create the actual Role object -- with the above policies
        #
        region = os.getenv("AWS_REGION")
        data['region'] = region
        #ldebug(f"Creating Role object: {role_name} for region: {region} ")
        iam_session = Session(region_name=region).resource('iam')
        service_role = iam_session.Role(role_name)
        #ldebug(f"Associating service role {service_role.arn} to account")
        gg.associate_service_role_to_account(RoleArn=service_role.arn)

        data["service_role_arn"] = service_role.arn
        #ldebug(f"Service role created: arn: {service_role.arn}")

    # role already exists return nothing, assuming previous success
    except ClientError as ce:
        if ce.response['Error']['Code'] == 'ResourceAlreadyExistsException':
            lwarning(f"Role {role_name} already exists: {0}".format(
                    ce.response['Error']['Message']))
        else:
            lerror("Role creation for {role_name} error: {0}".format(
                ce.response['Error']['Message']))
            raise ce

    #ldebug(f"Returning data from role creation: {json.dumps(data, indent=2)}")
    return data


def remove_iam_role_with_inline(data):
    #ldebug(f"Removing IAM inline role")
    role_name = data.get("gg_role_name", None)
    service_role_arn = data.get("service_role_arn", None)

    try:
        if role_name:
            #ldebug(f"Detach lambda role policy: {role_name}")
            iam.detach_role_policy(RoleName=role_name, PolicyArn=aws_lambda_ro_access_arn)
            #ldebug(f"Detach iot role policy: {role_name}")
            iam.detach_role_policy(RoleName=role_name, PolicyArn=aws_iot_full_access_arn)
            #ldebug(f"Deleting role: {role_name}")
            iam.delete_role(RoleName=role_name)
            #ldebug(f"[remove_iam_role] roles deleted")
    except Exception as e:
        lerror(f"Error removing role {role_name}: {str(e)}")
        raise e

    return data


#################################################################
# GG Group
#
def create_gg_group(prefix, data):
    device_id = data.get("id", None)
    group_name = f"{prefix}_gg_{device_id}"

    data['group_name'] = group_name
    try:
        #ldebug(f"Creating GG group with name: {group_name}")
        group = gg.create_group(Name=group_name)
        group_id = group['Id']
        data['group_id'] = group_id
        #ldebug(f"Created GG group with name: {group_name} - id: {group_id}")

    except Exception as e:
        lerror(f"Error creating GG group {group_name}: {str(e)}")
        raise e

    return data


def remove_gg_group(data):
    #ldebug(f"Removing GG Group")
    group_id = data.get("group_id", None)
    if group_id:
        try:
            #ldebug(f"Removing GG group with id: {group_id}")
            result = gg.delete_group(GroupId=group_id)

        except Exception as e:
            lerror(f"Error removing GG group {group_id}: {str(e)}")
            raise e

    return data


#################################################################
# GG Core
#
# This defines GG cores. The definition is passed in via
# the 'gg_core_def' key as a JSON that complies with this definition:
# https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/greengrass.html#Greengrass.Client.create_core_definition
#
# Example:
# {
#     'Cores': [
#         {
#             'CertificateArn': 'string',
#             'Id': 'string',
#             'SyncShadow': True|False,
#             'ThingArn': 'string'
#         },
#     ]
# }

def create_gg_core(prefix, data):
    device_id = data.get("id", "")
    core_def_name = f"{prefix}_gg_core_def_{device_id}"

    #ldebug(f"Creating GG Core {core_def_name}")

    # If no definition provided, let's create one.
    #
    core_def_json = data.get("gg_core_def", None)
    if not core_def_json:
        cert_arn = data.get('cert_arn', None)
        thing_arn = data.get('thing_arn', None)
        core_def_id = uuid.uuid4().hex
        core_def_json = {
            'Cores': [
                {
                    'CertificateArn': cert_arn,
                    'Id': core_def_id,
                    'SyncShadow': DEFAULT_GG_SYNC_SHADOW,
                    'ThingArn': thing_arn
                },
            ]
        }

    try:
        #ldebug(f"Creating GG core definition with name: {core_def_name} and json: {json.dumps(core_def_json, indent=4)}")
        core_def = gg.create_core_definition(Name=core_def_name, InitialVersion=core_def_json)
        data['core_def_name'] = core_def_name
        core_def_id = core_def['Id']
        data['core_def_id'] = core_def_id
        core_def_version_arn = core_def['LatestVersionArn']
        data['core_def_version_arn'] = core_def_version_arn

        # version = gg.create_core_definition_version(
        #         CoreDefinitionId=core_def_id,
        #         Cores=core_def)
        # core_def_arn = version['Arn']
        # core_def_version_arn = version['LatestVersionArn']
        # ldebug(f"Created GG core def version arn:{core_def_version_arn}")
        # ldebug(f"[create_gg_cores] Created Core Def Version arn: {core_def_version_arn}")
        # data['core_def_arn'] = core_def_arn
        # data['core_def_version_arn'] = core_def_version_arn

    except Exception as e:
        lerror(f"Error creating GG core definition {core_def_name}: {str(e)}")
        raise e

    return data


def remove_gg_core(data):
    #ldebug(f"Removing GG Core")
    core_def_id = data.get('core_def_id', None)
    if core_def_id:
        try:
            #ldebug(f"Removing GG core def with Id:{core_def_id}")
            result = gg.delete_core_definition(CoreDefinitionId=core_def_id)

        except Exception as e:
            lerror(f"Error removing GG core with id {core_def_id}: {str(e)}")
            raise e

    return data


#################################################################
# GG Devices
#
# This defines GG devices. The definition is passed in via
# the 'gg_device_def' key as a JSON that complies with this definition:
# https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/greengrass.html#Greengrass.Client.create_device_definition
#
# Example:
# {
#     'Devices': [
#         {
#             'CertificateArn': 'string',
#             'Id': 'string',
#             'SyncShadow': True|False,
#             'ThingArn': 'string'
#         },
#     ]
# }
#

def create_gg_devices(prefix, data):
    device_id = data.get("id", "")
    dev_def_name = f"{prefix}_gg_dev_def_{device_id}"
    group_name = data.get("group_name", None)
    dev_def_json = data.get("gg_device_def", None)
    if group_name and dev_def_json:
        try:
            #ldebug(f"Creating GG device definition and version: {dev_def_name}")
            dev_def = gg.create_device_definition(Name=dev_def_name, InitialVersion=dev_def_json)
            data['device_def_name'] = dev_def_name
            dev_def_id = dev_def['Id']
            data['device_def_id'] = dev_def_id
            version = gg.create_device_definition_version(
                DeviceDefinitionId=dev_def_id,
                Devices=dev_def)
            dev_def_version_arn = version['Arn']
            data['device_def_version_arn'] = dev_def_version_arn

        except Exception as e:
            lerror(f"Error creating GG device definition and version {dev_def_name}: {str(e)}")
            raise e

    return data


def remove_gg_devices(data):
    #ldebug(f"Removing GG Devices")
    device_def_id = data.get('device_def_id', None)
    if device_def_id:
        try:
            #ldebug(f"Deleting GG device definition: {device_def_id}")
            result = gg.delete_device_definition(DeviceDefinitionId=device_def_id)

        except Exception as e:
            lerror(f"Error removing GG device {device_def_id}: {str(e)}")
            raise e

    return data


#################################################################
# GG Resources
#
# Creates GG resources like local data, volumes, S3 learning models,
# SageMaker learning models, and Secrets Manager data on the edge
# device.
#
# This creates a GG local function. The definition is passed in via
# the 'gg_resource_def' key as a JSON that complies with this definition:
# https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/greengrass.html#Greengrass.Client.create_resource_definition
#
# Example:
# {
#     'Resources': [
#         {
#             'Id': 'string',
#             'Name': 'string',
#             'ResourceDataContainer': {
#                 'LocalDeviceResourceData': {
#                     'GroupOwnerSetting': {
#                         'AutoAddGroupOwner': True|False,
#                         'GroupOwner': 'string'
#                     },
#                     'SourcePath': 'string'
#                 },
#                 'LocalVolumeResourceData': {
#                     'DestinationPath': 'string',
#                     'GroupOwnerSetting': {
#                         'AutoAddGroupOwner': True|False,
#                         'GroupOwner': 'string'
#                     },
#                     'SourcePath': 'string'
#                 },
#                 'S3MachineLearningModelResourceData': {
#                     'DestinationPath': 'string',
#                     'OwnerSetting': {
#                         'GroupOwner': 'string',
#                         'GroupPermission': 'ro'|'rw'
#                     },
#                     'S3Uri': 'string'
#                 },
#                 'SageMakerMachineLearningModelResourceData': {
#                     'DestinationPath': 'string',
#                     'OwnerSetting': {
#                         'GroupOwner': 'string',
#                         'GroupPermission': 'ro'|'rw'
#                     },
#                     'SageMakerJobArn': 'string'
#                 },
#                 'SecretsManagerSecretResourceData': {
#                     'ARN': 'string',
#                     'AdditionalStagingLabelsToDownload': [
#                         'string',
#                     ]
#                 }
#             }
#         },
#     ]
# }

def create_gg_resources(prefix, data):
    device_id = data.get("id", "")
    res_def_name = f"{prefix}_gg_res_def_{device_id}"
    group_name = data.get("group_name", None)
    res_def_json = data.get("gg_resource_def", None)
    if group_name and res_def_json:
        try:
            #ldebug(f"Creating GG resource definition and version: {res_def_name}")
            res_def = gg.create_resource_definition(Name=res_def_name, InitialVersion=res_def_json)
            data['resource_def_name'] = res_def_name
            res_def_id = res_def['Id']
            data['resource_def_id'] = res_def_id
            version = gg.create_resource_definition_version(
                ResourceDefinitionId=res_def_id,
                Resources=res_def)
            res_def_version_arn = version['Arn']
            #ldebug(f"Created Resource Def Version arn: {res_def_version_arn}")
            data['resource_def_version_arn'] = res_def_version_arn

        except Exception as e:
            lerror(f"Error creating GG resource definition and version: {str(e)}")
            raise e

    return data


def remove_gg_resources(data):
    #ldebug(f"Removing GG Resources")
    res_def_id = data.get('resource_def_id', None)
    if res_def_id:
        try:
            #ldebug(f"Deleting GG resource definition: {res_def_id}")
            result = gg.delete_resource_definition(ResourceDefinitionId=res_def_id)

        except Exception as e:
            lerror(f"Error removing GG resource {res_def_id}: {str(e)}")
            raise e

    return data


#################################################################
# GG Lambdas
#
# This creates a GG local function. The definition is passed in via
# the 'gg_lambda_def' key as a JSON that complies with this definition:
# https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/greengrass.html#Greengrass.Client.create_function_definition
#
# Example:
# {
#     'DefaultConfig': {
#         'Execution': {
#             'IsolationMode': 'GreengrassContainer'|'NoContainer',
#             'RunAs': {
#                 'Gid': 123,
#                 'Uid': 123
#             }
#         }
#     },
#     'Functions': [
#         {
#             'FunctionArn': 'string',
#             'FunctionConfiguration': {
#                 'EncodingType': 'binary'|'json',
#                 'Environment': {
#                     'AccessSysfs': True|False,
#                     'Execution': {
#                         'IsolationMode': 'GreengrassContainer'|'NoContainer',
#                         'RunAs': {
#                             'Gid': 123,
#                             'Uid': 123
#                         }
#                     },
#                     'ResourceAccessPolicies': [
#                         {
#                             'Permission': 'ro'|'rw',
#                             'ResourceId': 'string'
#                         },
#                     ],
#                     'Variables': {
#                         'string': 'string'
#                     }
#                 },
#                 'ExecArgs': 'string',
#                 'Executable': 'string',
#                 'MemorySize': 123,
#                 'Pinned': True|False,
#                 'Timeout': 123
#             },
#             'Id': 'string'
#         },
#     ]
# }
#

def create_gg_lambdas(prefix, data):
    device_id = data.get("id", "")
    lambda_def_name = f"{prefix}_gg_lambda_def_{device_id}"
    group_name = data.get("group_name", None)
    lambda_def_json = data.get("gg_lambda_def", None)
    gg_lambda_arn = data.get("gg_lambda_arn")

    if lambda_def_json and gg_lambda_arn:
        gg_lambda_env_key = data.get("gg_lambda_env_key")
        gg_lambda_env_value = data.get("gg_lambda_env_value")
        function_guid = uuid.uuid4().hex

        lambda_def_json = {
            'Functions': [
                {
                    'FunctionArn': gg_lambda_arn,
                    'FunctionConfiguration': {
                        'EncodingType': 'json',
                        'Environment': {
                            'Variables': {
                                gg_lambda_env_key: gg_lambda_env_value
                            }
                        },
                        'MemorySize': 16000,
                        # 16MB assigned to each function. If you need more, either increase or specify own
                        'Pinned': True,
                        'Timeout': 10
                    },
                    'Id': function_guid
                },
            ]}
        #ldebug(f"Creating lambda with JSON definition: {json.dumps(lambda_def_json, indent=2)}")

        try:
            #ldebug(f"Creating GG lambda definition and version: {lambda_def_name}")
            lambda_def = gg.create_function_definition(Name=lambda_def_name, InitialVersion=lambda_def_json)
            data['lambda_def_name'] = lambda_def_name
            lambda_def_id = lambda_def['Id']
            data['lambda_def_id'] = lambda_def_id
            lambda_def_version = lambda_def['LatestVersionArn']
            data['lambda_def_version_arn'] = lambda_def_version
            #ldebug(f"Created GG lambda definition id: {lambda_def_id} and version: {lambda_def_version}")

            # version = gg.create_function_definition_version(
            #         FunctionDefinitionId=lambda_def_id,
            #         Functions=lambda_def)
            # lambda_def_version_arn = version['Arn']
            # ldebug(f"[create_gg_lambdas] Created Lambda Def Version arn: {lambda_def_version_arn}")

        except Exception as e:
            lerror(f"Error creating GG lambda definition and version: {str(e)}")
            raise e

    return data


def remove_gg_lambdas(data):
    #ldebug(f"Removing GG lambdas")
    lambda_def_id = data.get('lambda_def_id', None)
    if lambda_def_id:
        try:
            #ldebug(f"Deleting GG lambda definition: {lambda_def_id}")
            result = gg.delete_function_definition(FunctionDefinitionId=lambda_def_id)

        except Exception as e:
            lerror(f"Error deleting GG lambda function definition {lambda_def_id}: {str(e)}")
            raise e

    return data


#################################################################
# GG Connectors
#
# This creates a GG connector. The definition is passed in via
# the 'gg_connector_def' key as a JSON that complies with this definition:
# https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/greengrass.html#Greengrass.Client.create_connector_definition
#
# Example:
# {
#     'Connectors': [
#         {
#             'ConnectorArn': 'string',
#             'Id': 'string',
#             'Parameters': {
#                 'string': 'string'
#             }
#         },
#     ]
# }

def create_gg_connectors(prefix, data):
    device_id = data.get("id", "")
    conn_def_name = f"{prefix}_gg_conn_def_{device_id}"
    group_name = data.get("group_name")
    conn_def_json = data.get("gg_connector_def", None)
    if group_name and conn_def_json:
        try:
            #ldebug(f"Creating GG connector definition and version: {conn_def_name}")
            conn_def = gg.create_connector_definition(Name=conn_def_name, InitialVersion=conn_def_json)
            data['conn_def_name'] = conn_def_name
            conn_def_id = conn_def['Id']
            data['conn_def_id'] = conn_def_id
            version = gg.create_connection_definition_version(
                ConnectorDefinitionId=conn_def_id,
                Connectors=conn_def)
            conn_def_version_arn = version['Arn']
            data['conn_def_version_arn'] = conn_def_version_arn

        except Exception as e:
            lerror(f"Error creating GG connector definition and version {conn_def_name}: {str(e)}")
            raise e

    return data


def remove_gg_connectors(data):
    #ldebug(f"Removing GG connectors")
    conn_def_id = data.get('conn_def_id', None)
    if conn_def_id:
        try:
            #ldebug(f"Deleting GG connector definition: {conn_def_id}")
            result = gg.delete_connector_definition(ConnectorDefinitionId=conn_def_id)

        except Exception as e:
            lerror(f"Error deleting GG connector definition: {conn_def_id}: {str(e)}")
            raise e

    return data


#################################################################
# GG Subscriptions
#
# This creates GG subscriptions. The definition is passed in via
# the 'gg_subscription_def' key as a JSON that complies with this definition:
# https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/greengrass.html#Greengrass.Client.create_subscription_definition
#
# Example:
# {
#     'Subscriptions': [
#         {
#             'Id': 'string',
#             'Source': 'string',
#             'Subject': 'string',
#             'Target': 'string'
#         },
#     ]
# }

def create_gg_subscriptions(prefix, data):
    device_id = data.get("id", "")
    subs_def_name = f"{prefix}_gg_sub_def_{device_id}"
    group_name = data.get("group_name")
    subs_def_json = data.get("gg_subscription_def", None)
    if group_name and subs_def_json:
        try:
            #ldebug(f"Creating GG subscription definition and version: {subs_def_name}")
            subs_def = gg.create_subscription_definition(Name=subs_def_name, InitialVersion=subs_def_json)
            data['subs_def_name'] = subs_def_name
            subs_def_id = subs_def['Id']
            data['subs_def_id'] = subs_def_id
            subs_def_version_arn = subs_def['LatestVersionArn']
            #ldebug(f"Created Subscription Def Version arn: {subs_def_version_arn}")
            data['subs_def_version_arn'] = subs_def_version_arn

        except Exception as e:
            lerror(f"Error creating GG subscription definition and version: {subs_def_name}: {str(e)}")
            raise e

    return data


def remove_gg_subscriptions(data):
    #ldebug(f"Removing GG subscriptions")
    subs_def_id = data.get('subs_def_id', None)
    if subs_def_id:
        try:
            #ldebug(f"Removing GG subscription definition: {subs_def_id}")
            result = gg.delete_subscription_definition(SubscriptionDefinitionId=subs_def_id)

        except Exception as e:
            lerror(f"Error removing GG subscription definition: {subs_def_id}: {str(e)}")
            raise e

    return data


#################################################################
# GG Models
#
def create_gg_models(prefix, data):
    #ldebug(f"Creating GG Models")
    return data


def remove_gg_models(data):
    #ldebug(f"Removing GG models")
    return data


#################################################################
# GG Loggers
#
# This creates GG Loggers. The definition is passed in via
# the 'gg_logger_def' key as a JSON that complies with this definition:
# https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/greengrass.html#Greengrass.Client.create_logger_definition
#
# Example:
# {
#     'Loggers': [
#         {
#             'Component': 'GreengrassSystem'|'Lambda',
#             'Id': 'string',
#             'Level': 'DEBUG'|'INFO'|'WARN'|'ERROR'|'FATAL',
#             'Space': 123,
#             'Type': 'FileSystem'|'AWSCloudWatch'
#         },
#     ]
# }

def create_gg_loggers(prefix, data):
    device_id = data.get("id", "")
    log_def_name = f"{prefix}_gg_log_def_{device_id}"
    group_name = data.get("group_name")
    log_def_json = data.get("gg_logger_def", None)
    if group_name and log_def_json:
        try:
            #ldebug(f"Creating GG logger definition and version {log_def_name}")
            log_def = gg.create_logger_definition(Name=log_def_name, InitialVersion=log_def_json)
            data['log_def_name'] = log_def_name
            log_def_id = log_def['Id']
            data['log_def_id'] = log_def_id
            version = gg.create_logger_definition_version(
                LoggerDefinitionId=log_def_id,
                Loggers=log_def)
            log_def_version_arn = version['Arn']
            #ldebug(f"Created GG logger Def Version arn: {log_def_version_arn}")
            data['log_def_version_arn'] = log_def_version_arn

        except Exception as e:
            lerror(f"Error creating GG logger definition and version {log_def_name}: {str(e)}")
            raise e

    return data


def remove_gg_loggers(data):
    #ldebug(f"Removing GG loggers")
    log_def_id = data.get('log_def_id', None)
    if log_def_id:
        try:
            #ldebug(f"Deleting GG logger definition: {log_def_id}")
            result = gg.delete_logger_definition(SubscriptionDefinitionId=log_def_id)

        except Exception as e:
            lerror(f"Deleting GG logger definition: {log_def_id}: {str(e)}")
            raise e

    return data


#################################################################
# GG Version
#
# This has to be called in order for this to show up in the console.
#
def create_gg_version(prefix, data):

    group_id = data.get("group_id", None)
    conn_def_version_arn = data.get("conn_def_version_arn", None)
    core_def_version_arn = data.get("core_def_version_arn", None)
    dev_def_version_arn = data.get("dev_def_version_arn", None)
    lambda_def_version_arn = data.get("lambda_def_version_arn", None)
    log_def_version_arn = data.get("log_def_version_arn", None)
    res_def_version_arn = data.get("res_def_version_arn", None)
    subs_def_version_arn = data.get("subs_def_version_arn", None)

    if group_id:
        try:
            # We're dynamically generating the parameter list since create_group_version
            # does parameter validation and None values are not allowed.
            #
            param_dict = {
                'GroupId': group_id,
            }
            if conn_def_version_arn:
                param_dict['ConnectorDefinitionVersionArn'] = conn_def_version_arn
            if core_def_version_arn:
                param_dict['CoreDefinitionVersionArn'] = core_def_version_arn
            if dev_def_version_arn:
                param_dict['DeviceDefinitionVersionArn'] = dev_def_version_arn
            if lambda_def_version_arn:
                param_dict['FunctionDefinitionVersionArn'] = lambda_def_version_arn
            if log_def_version_arn:
                param_dict['FunctionDefinitionVersionArn'] = log_def_version_arn
            if res_def_version_arn:
                param_dict['ResourceDefinitionVersionArn'] = res_def_version_arn
            if subs_def_version_arn:
                param_dict['SubscriptionDefinitionVersionArn'] = subs_def_version_arn

            #ldebug(f"Creating GG group version with param: {json.dumps(param_dict, indent=4)}")

            version = gg.create_group_version(**param_dict)
            group_version_arn = version['Arn']
            data['group_version_arn'] = group_version_arn
            group_version_id = version['Version']
            data['group_version_id'] = group_version_id
            #ldebug(f"Created GG group version Id: {group_version_id} Arn: {group_version_arn}")

        except Exception as e:
            lerror(f"Error creating GG group version with group ID {group_id}: {str(e)}")
            raise e

    return data


#################################################################
# GG Deploy
#
# Creates a deployment for this group version.
#
def deploy_gg(prefix, data):
    #ldebug(f"Creating GG Deployment")
    group_id = data['group_id']
    group_version_id = data['group_version_id']
    if group_id and group_version_id:
        try:
            #ldebug(f"Creating GG deployment for group {group_id} and version id {group_version_id}")
            deploy = gg.create_deployment(
                GroupId=group_id,
                GroupVersionId=group_version_id,
                DeploymentType="NewDeployment"
            )
            deploy_id = deploy['DeploymentId']
            deploy_arn = deploy['DeploymentArn']
            data['deploy_id'] = deploy_id
            data['deploy_arn'] = deploy_arn
            #ldebug(f"Created GG deployment. id: {deploy_id} - arn: {deploy_arn} ")

        except Exception as e:
            lerror(f"Error creating GG deployment for group {group_id} and version id {group_version_id}: {str(e)}")
            raise e

    return data


def reset_gg_deployments(data):
    #ldebug(f"Reset GG Deployment")
    group_id = data['group_id']
    if group_id:
        try:
            #ldebug(f"Resetting Group Deployment for group {group_id}")
            deployments = gg.list_deployments(
                GroupId=group_id,
                MaxResults='1'
            )
            deploy_count = len(deployments['Deployments'])
            if deploy_count > 0:
                gg.reset_deployments(GroupId=group_id)
                #ldebug(f"Requested Deployment Reset for {deploy_count} groups(s) for group {group_id}")

        except Exception as e:
            lerror(f"Error resetting Group Deployment for group {group_id}: {str(e)}")

    return data
