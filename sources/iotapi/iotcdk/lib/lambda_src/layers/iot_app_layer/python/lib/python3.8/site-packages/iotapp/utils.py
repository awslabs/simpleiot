# Â© 2022 Amazon Web Services, Inc. or its affiliates. All Rights Reserved.
#
# SimpleIOT project.
# Author: Ramin Firoozye (framin@amazon.com)
#
# SimpleIOT: App Layer: Utilities
# utils.py
#

from pony.orm.core import BindingError, count
import json
import uuid
import datetime
from .logger import *
from .dbschema import *
import os
import enum
import boto3
from botocore.exceptions import ClientError


# NOTE: 'db' is an app singleton and is globally defined in dbschema.py.
#
########################################################################
# Most of the settings come from environment variables in the lambda.
# We only get the password out of secretsmanager to ensure
# security compliance.
#
def connect_database_with_secretsmanager():
    #ldebug("Connecting to DB with SecretsManager")
    try:
        db_type, db_host, db_port, db_user, db_pass, db_name = get_db_login_data()
        if not db_type:
            lerror("ERROR: can not get DB login data")
            return

        # The DB_PASS_KEY is the key used to get the password out of secrets manager
        # It's defined in the installer bootstrap and is passed down to us during
        # lambda creation.
        #
        db.bind(db_type,
                user=db_user,
                password=db_pass,
                host=db_host,
                database=db_name,
                port=str(db_port))
    except BindingError:
        lerror("Error connective to database with bind")
        pass

    try:
        #ldebug("Generating DB mapping")
        db.generate_mapping(check_tables=True, create_tables=False)
    except BindingError:
        pass


def connect_database():
    #ldebug("Connecting to database")
    db.disconnect()  # clean up old connections
    connect_database_with_secretsmanager()
    #ldebug("DB Connected")


def disconnect_db():
    #ldebug("Disconnecting from database")
    db.disconnect()


def json_serial_as_string(obj):
    """JSON serializer for objects not serializable by default json code"""

    if isinstance(obj, (datetime, datetime.date)):
        return obj.isoformat()
    if isinstance(obj, uuid.UUID):
        return obj.hex
    raise TypeError("Type %s not serializable" % type(obj))


def convert_one_to_json(entity):
    if entity:
        result = entity.to_dict()
        return json.dumps(result, default=json_serial_as_string)
    else:
        return None


def convert_all_to_json(entity_list, as_str=True):
    result = []
    #ldebug("Got entity list")
    for e in entity_list:
        #ldebug(f"E: {str(e)}")
        one = e.to_dict()
        #ldebug(f"Entity Dict: {str(one)}")
        result.append(one)
    if as_str:
        return json.dumps(result, default=json_serial_as_string)
    else:
        return result

#
# This is used by lambdas to look for common API parameters and use it to
# find a project by ID or name and get the object
#
def find_project(params):
    """
    Standard way to find a project. It looks for project_id, project, and project_name
    attributes to look for. project and project_name are the same.
    :param params:
    :return:
    """
    project = None
    if params:
        if params:
            proj_id = params.get("project_id", None)
            if proj_id:
                #ldebug(f"Getting record with ID: {proj_id}")
                proj_guid = uuid.UUID(proj_id)
                project = Project.get(id=proj_guid)
            else:
                project_name = params.get("project", None)
                if not project_name:
                    project_name = params.get("project_name", None)

                if project_name:
                    #ldebug(f"Getting project with name: {project_name}")
                    project = Project.get(name=project_name)

    if not project:
        lerror("ERROR: no project found")

    return project

#
# This is used by lambdas to look for common API parameters and use it to
# find a model by ID or name and get the object
#
def find_model(params, project):
    """
    Standard way to find a Model. It looks for model_id, and model
    parameters to look for.
    :param params:
    :return:
    """
    model = None

    if params:
        model_name = params.get("model_name", None)
        if not model_name:
            model_name = params.get("model", None)
        if model_name:
            #ldebug(f"Getting model with name: {model_name}")
            model = Model.select(lambda m: m.model_project == project and m.name == model_name).first()
        else:
            model_id = params.get("model_id", None)
            if model_id:
                #ldebug(f"Getting model with ID: {model_id}")
                model_guid = uuid.UUID(model_id)
                model = Model.select(lambda m: m.model_project == project and m.id == model_guid).first()

    return model

#
# This is used by lambdas to look for common API parameters and use it to
# find a device by ID or name and get the object
#
def find_device(params, project):
    """
    Returns a device record, looking for either id or serial parameters.
    If found, returns it so it can be processed.
    :param params:
    :return:
    """
    device = None
    if params:
        device_id = params.get("device_id", None)
        if device_id:
            #ldebug(f"Getting record with ID: {device_id}")
            device_guid = uuid.UUID(device_id)
            device = Device.select(lambda d: d.device_project == project and d.id == device_guid).first()
        else:
            serial = params.get("serial", None)
            if not serial:
                serial = params.get("device", None)
            if serial:
                #ldebug(f"Getting record with serial: {serial}")
                device = Device.select(lambda d: d.device_project == project and d.serial_number == serial).first()
    return device

#
# Utility routine to get count of devices of type model in the database. If it's zero, no such devices exist.
#
def get_count_of_devices_by_model(model):
    try:
        device_count = 0
        if model:
            #ldebug(f"Getting model with name: {model.name}")
            device_count = count(d for d in Device if d.model == model)

    except Exception as e:
        lerror(f"Error getting devices of model {model.name}: {str(e)}")
        pass

    #ldebug(f"Got {device_count} devices of type {model.name}")
    return device_count


def str2bool(v):
  return v.lower() in ("yes", "true", "t", "1")

##############################################################################
# This allows looking up a string from elements of an Enum.
# Used to lookup device model fields. The lookup is case-insensitive.
#
def enum_from_str(en, nm):
    try:
        for item in en:
            if nm.lower() == item.name.lower():
                return item.value

        raise ValueError(f"Invalid value specified for enum {str(en)}")
    except Exception as e:
        lerror(f"Error: {e}")
        return None

#
# This reverses the above and returns the string value of an enum.
# Used to display or export an enum into a config file.
#
def enum_to_str(en, item):
    result = None
    try:
        result = en(item).name.lower()
    except Exception as e:
        pass

    return result

# This does the above, except it looks for a list of string values,
# which it then turns into an ORed bitflag.
#
# The values are assumed to be comma-separated and each a valid item in the
# enum. We don't check for duplicates.
#
def enum_from_str_list(en, nml):
    flag = 0
    slist = nml.split(",")
    try:
        for st in slist:
            for item in en:
                if st.strip().lower() == item.name.lower():
                    flag |= int(item.value)
                    break
        return flag
    except Exception as e:
        lerror(f"Error: {e}")
        return None

#
# This does the reverse, except it returns a list of enums.
#
def enum_to_str_list(en, value):
    result = []
    try:
        for b in range(1, len(en) + 1):
            cb = b - 1
            item = en(1 << cb)
            if (value & (1 << (b - 1))):
                result.append(item.name)
        result_count = len(result)
        if result_count > 1:
            return ", ".join(result)
        elif result_count == 1:
            return result[0]
        else:
            return ""
    except Exception as e:
        lerror(f"ERROR: {str(e)}")
        pass
    return result

##############################################################################
# This is used to get a secret out of secretsmanager. Things like database
# passwords, etc.
#
def get_secret(secret_name):
    region = os.environ['AWS_REGION']

    try:
        client = boto3.client(service_name='secretsmanager', region_name=region)
    except Exception as e:
        lerror(f"No access to secretsmanager: {str(e)}")
        pass


    # In this sample we only handle the specific exceptions for the 'GetSecretValue' API.
    # See https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_GetSecretValue.html
    # We rethrow the exception by default.

    try:
        secret_value = client.get_secret_value(
            SecretId=secret_name
        )
    except ClientError as e:
        #lerror(f"Got exception: {str(e)}")

        if e.response['Error']['Code'] == 'DecryptionFailureException':
            # Secrets Manager can't decrypt the protected secret text using the provided KMS key.
            # Deal with the exception here, and/or rethrow at your discretion.
            raise e
        elif e.response['Error']['Code'] == 'InternalServiceErrorException':
            # An error occurred on the server side.
            # Deal with the exception here, and/or rethrow at your discretion.
            raise e
        elif e.response['Error']['Code'] == 'InvalidParameterException':
            # You provided an invalid value for a parameter.
            # Deal with the exception here, and/or rethrow at your discretion.
            raise e
        elif e.response['Error']['Code'] == 'InvalidRequestException':
            # You provided a parameter value that is not valid for the current state of the resource.
            # Deal with the exception here, and/or rethrow at your discretion.
            raise e
        elif e.response['Error']['Code'] == 'ResourceNotFoundException':
            # We can't find the resource that you asked for.
            # Deal with the exception here, and/or rethrow at your discretion.
            raise e
    else:
        # Decrypts secret using the associated KMS CMK.
        # Depending on whether the secret is a string or binary, one of these fields will be populated.
        if 'SecretString' in secret_value:
            secret = secret_value["SecretString"]

            return json.loads(secret)
        else:
            return None

def get_db_login_data():
    try:
        DB_PASS_KEY = os.environ['DB_PASS_KEY']
        password_data = get_secret(DB_PASS_KEY)
        if password_data:
            dbtype = password_data["engine"]
            dbhost = password_data["host"]
            port = password_data["port"]
            username = password_data["username"]
            password = password_data["password"]
            dbname = password_data["dbname"]
            return dbtype, dbhost, port, username, password, dbname
    except Exception as e:
        pass

    lerror(f"ERROR: could not obtain DB credentials from SecretsManager.")
    return None, None, None, None, None, None

#
# This is where we return the response headers returned by API calls. Method is passed
# down in case we need to return a different value per method.
#
def return_response_headers(method):
    response_headers = {
        "Access-Control-Allow-Origin": "*",  # NOTE: for development only
        "Access-Control-Allow-Headers": "Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,X-Amz-User-Agent",
        "Access-Control-Allow-Credentials": True,
        "Access-Control-Allow-Methods": "DELETE,GET,HEAD,OPTIONS,PATCH,POST,PUT",
        "Content-Type": "application/json"
    }
    return response_headers
